/*
 * SPDX-License-Identifier: Apache-2.0
 * Copyright 2016-2022 Daniel Urban and contributors listed in NOTICE.txt
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dev.tauri.choam

import java.util.concurrent.ThreadLocalRandom

/**
 * Utilities for exponential backoff.
 */
object Backoff extends BackoffPlatform {

  /**
   * Truncated exponential backoff.
   *
   * Backoff is implemented with spin-waiting, by calling
   * `Thread.onSpinWait` a number of times. The number of
   * calls starts at 1, doubles for each retry, and is
   * truncated at `maxBackoff`.
   *
   * That is, for retries = 0, 1, 2, 3, ... there will be
   * 1, 2, 4, 8, ... calls to `onSpinWait`.
   *
   * @param retries is the number of retries so far (retries = 0, for
   *                the backoff before the first retry).
   * @param maxBackoff is the maximum number of calls to `onSpinWait`
   *                   to make.
   */
  final def backoffConst(retries: Int, maxBackoff: Int): Unit =
    spin(constTokens(retries, maxBackoff))

  private[choam] final def constTokens(retries: Int, maxBackoff: Int): Int =
    Math.min(1 << normalizeRetries(retries), maxBackoff)

  final def backoffRandom(retries: Int, halfMaxBackoff: Int): Unit =
    backoffRandom(retries, halfMaxBackoff, ThreadLocalRandom.current())

  /**
   * Randomized truncated exponential backoff.
   *
   * Backoff is implemented with spin-waiting, by calling
   * `Thread.onSpinWait` a number of times. The number of calls
   * is uniformly random, but at least 1, and its expected value
   * is approximately the number of calls `backoffConst` would
   * make (when called with the same parameters).
   *
   * That is, for retries = 0, 1, 2, ... the number of calls
   * will be in the intervals [1, 2], [1, 4], [1, 8], ...
   *
   * The random value is generated by a thread-local generator,
   * so different threads will likely generate different values.
   *
   * @param retries is the number of retries so far (retries = 0, for
   *                the backoff before the first retry).
   * @param halfMaxBackoff is the half of the maximum number of calls
   *                       to `onSpinWait` to make.
   * @param random the thread-local rng of the current thread.
   */
  final def backoffRandom(retries: Int, halfMaxBackoff: Int, random: ThreadLocalRandom): Unit =
    spin(randomTokens(retries, halfMaxBackoff, random))

  private[choam] final def randomTokens(retries: Int, halfMaxBackoff: Int, random: ThreadLocalRandom): Int = {
    val max = Math.min(1 << normalizeRetries(retries + 1), halfMaxBackoff << 1)
    if (max < 2) 1
    else 1 + random.nextInt(max)
  }

  @tailrec
  private[choam] final def spin(n: Int): Unit = {
    if (n > 0) {
      once()
      spin(n - 1)
    }
  }

  /**
   * The greatest "usable" number of retries is 30,
   * since 1 << 31 is negative.
   */
  private final def normalizeRetries(retries: Int): Int =
    Math.min(retries, 30)
}
